package me.wallhacks.spark.systems.module.modules.exploit;

import me.wallhacks.spark.Spark;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerDamageBlockEvent;
import me.wallhacks.spark.event.player.PlayerLivingTickEvent;
import me.wallhacks.spark.systems.clientsetting.clientsettings.AntiCheatConfig;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.module.modules.combat.CrystalAura;
import me.wallhacks.spark.systems.setting.settings.BooleanSetting;
import me.wallhacks.spark.systems.setting.settings.IntSetting;
import me.wallhacks.spark.util.MC;
import me.wallhacks.spark.util.player.itemswitcher.ItemSwitcher;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.ItemForMineSwitchItem;
import me.wallhacks.spark.util.render.EspUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.lwjgl.input.Mouse;

import java.awt.*;

@Module.Registration(name = "InstaMine", description = "Packet mine but good!",alwaysListening = true)
public class InstaMine extends Module implements MC {

	public static InstaMine instance;
	public InstaMine() {
		instance = this;

	}

	IntSetting delay = new IntSetting("Delay", this, 0, 0, 10, "General");
	BooleanSetting swing = new BooleanSetting("Swing", this, false, "General");

	BooleanSetting onClickDisable = new BooleanSetting("OnClickDisable", this, true, "General");



	BooleanSetting ifBlock = new BooleanSetting("PauseIfEmpty", this, true, "Packets");
	BooleanSetting onDone = new BooleanSetting("WaitProgress", this, false, "Packets");
	BooleanSetting sameItem = new BooleanSetting("IfSameItem", this, true, "Packets");
	BooleanSetting onPick = new BooleanSetting("OnPick", this, false, "Packets");



	boolean hasStarted = false;
	public BlockPos pos;
	EnumFacing facing;

	float progress = 0f;

	Item usedForBreak = null;

	int pauseTimer = 0;

	@SubscribeEvent
	public void onBreak(PlayerDamageBlockEvent.Pre event){

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
			return;

		if(onPick.isOn() && Items.DIAMOND_PICKAXE != mc.player.getHeldItemMainhand().getItem())
			return;


		if (!canBreak(event.getPos()))
			return;

		if(pos == null || !pos.equals(event.getPos())){
			progress = 0;
			hasStarted = false;
			usedForBreak = null;
		}

		pos = event.getPos();
		facing = event.getFacing();



		if(!hasStarted){
			mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
			mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
			usedForBreak = mc.player.getHeldItemMainhand().getItem();
			hasStarted = true;
		}


		event.setReturnValue(false);
		event.setCanceled(true);
	}


	@SubscribeEvent
	public void onUpdate(PlayerLivingTickEvent event) {

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
		{
			if(pos != null)
				pos = null;
			return;
		}

		if(pauseTimer > 0)
			pauseTimer--;
		else if(pos != null)
		{

			IBlockState b = mc.world.getBlockState(pos);

			if(hasStarted && (b.getBlock() != Blocks.AIR || !ifBlock.isOn()))
			{
				progress += b.getPlayerRelativeBlockHardness(this.mc.player, this.mc.player.world, pos);


				if(sameItem.isOn() && usedForBreak != mc.player.getHeldItemMainhand().getItem())
					return;

				if(swing.isOn())
					mc.player.swingArm(EnumHand.MAIN_HAND);

				if(onDone.isOn() && progress < 1f)
					return;
				if(pauseTimer > 0)
					return;


				mc.player.connection.sendPacket(new CPacketPlayerDigging(
						CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing
				));
				pauseTimer = delay.getValue();
				usedForBreak = mc.player.getHeldItemMainhand().getItem();
			}

			if(onClickDisable.isOn())
				if(Mouse.isButtonDown(0) && ((onPick.isOn() && Items.DIAMOND_PICKAXE != mc.player.getHeldItemMainhand().getItem()) || mc.objectMouseOver == null || mc.objectMouseOver.typeOfHit == RayTraceResult.Type.MISS))
				{
					pos = null;
					facing = null;

				}

		}

	}


	@SubscribeEvent
	public void onPacket(PacketSendEvent event) {


		if (event.getPacket() instanceof CPacketPlayerDigging)
		{
			CPacketPlayerDigging digging = event.getPacket();
			if(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK == digging.getAction())
			{
				if(pos != null)
					event.setCanceled(true);
			}
		}
	}

	@SubscribeEvent
	public void onRender(RenderWorldLastEvent event) {


		if(pos != null)
		{
			AxisAlignedBB B = MC.mc.world.getBlockState(pos).getSelectedBoundingBox(MC.mc.world, pos);

			EspUtil.boundingESPBox(new AxisAlignedBB(pos),new Color(157, 146, 146, 171), 2.0f);


		}

	}


	private boolean canBreak(BlockPos pos)
	{
		final IBlockState blockState = mc.world.getBlockState(pos);
		final Block block = blockState.getBlock();

		return block.getBlockHardness(blockState, mc.world, pos) != -1;
	}

}
