package me.wallhacks.spark.systems.module.modules.exploit;

import me.wallhacks.spark.Spark;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerUpdateEvent;
import me.wallhacks.spark.event.world.WorldLoadEvent;
import me.wallhacks.spark.systems.clientsetting.clientsettings.AntiCheatConfig;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.module.modules.combat.Surround;
import me.wallhacks.spark.systems.setting.settings.BooleanSetting;
import me.wallhacks.spark.systems.setting.settings.IntSetting;
import me.wallhacks.spark.systems.setting.settings.ModeSetting;
import me.wallhacks.spark.util.MC;
import me.wallhacks.spark.util.WorldUtils;
import me.wallhacks.spark.util.objects.Vec2i;
import me.wallhacks.spark.util.player.BlockInteractUtil;
import me.wallhacks.spark.util.player.PlayerUtil;
import me.wallhacks.spark.util.player.RaytraceUtil;
import me.wallhacks.spark.util.player.itemswitcher.ItemSwitcher;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.HardSolidBlockSwitchItem;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.SpecBlockSwitchItem;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.SpecItemSwitchItem;
import net.minecraft.block.Block;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.init.Blocks;
import net.minecraft.item.Item;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Arrays;
import java.util.List;

@Module.Registration(name = "Burrow", description = "Burrow lol")
public class Burrow extends Module implements MC {



	BooleanSetting Rotate = new BooleanSetting("Rotate",this,true);


	ModeSetting ItemMode = new ModeSetting("ItemMode",this,"Echest", Arrays.asList("Echest","Obsidian","Beacon"));
	BooleanSetting UseOtherBlocks = new BooleanSetting("AllowOtherBlocks",this,true);


	BooleanSetting OneTick = new BooleanSetting("OneTick",this,false);
	BooleanSetting KeepPlayer = new BooleanSetting("KeepPlayer",this,false);
	BooleanSetting center = new BooleanSetting("Center",this,true);
	BooleanSetting bypass = new BooleanSetting("Bypass",this,false);




	@Override
	public void onEnable() {
		super.onEnable();
		if(!mc.player.onGround
				|| mc.world.checkBlockCollision(mc.player.boundingBox.expand(0, 1, 0))
				|| !mc.world.getBlockState(PlayerUtil.getPlayerPosFloored(mc.player)).getBlock().material.isReplaceable()
		)
		{
			this.setEnabled(false);
			return;
		}
		status = 0;
	}


	int status = 0;

	@SubscribeEvent
	void onWorld(WorldLoadEvent event) {
		setEnabled(false);
	}

	@SubscribeEvent
	void OnUpdate(PlayerUpdateEvent event) {


		BlockPos floored = PlayerUtil.getPlayerPosFloored(mc.player,0.2);
		BlockPos pos = floored.add(0,-1,0);

		if(mc.world.getBlockState(floored).getBlock().material.isSolid()
				&& !mc.world.getBlockState(floored.add(0,1,0)).getBlock().material.isSolid()){

			if(bypass.isOn())
			{
				mc.player.motionY = 0;
			}
			else if(KeepPlayer.isOn()){
				Vec3d Center = new Vec3d(pos.getX()+0.5,pos.getY(),pos.getZ()+0.5);
				double l_XDiff = Math.abs(Center.x - mc.player.posX);
				double l_ZDiff = Math.abs(Center.z - mc.player.posZ);

				if (l_XDiff <= 0.1 && l_ZDiff <= 0.1)
				{
					Center = Vec3d.ZERO;
				}
				else
				{
					double l_MotionX = Center.x-mc.player.posX;
					double l_MotionZ = Center.z-mc.player.posZ;

					mc.player.motionX = l_MotionX*0.6f;
					mc.player.motionZ = l_MotionZ*0.6f;
				}

			}




		}
		else if(status > 20)
			this.setEnabled(false);



		if(status == 0){
			if(!mc.player.onGround)
			{
				this.setEnabled(false);
				return;
			}
			else {
				List<Entity> l = mc.world.getEntitiesWithinAABBExcludingEntity(mc.player, new AxisAlignedBB(floored));
				for(Entity e : l){
					if(!(e instanceof EntityItem) && !e.isDead)
					{
						this.setEnabled(false);
						return;
					}
				}
			}

			if(Surround.instance.isPlacing())
				return;


			if(center.isOn()){


				Vec3d Center = new Vec3d(pos.getX()+0.5,pos.getY(),pos.getZ()+0.5);



				double l_XDiff = Math.abs(Center.x - mc.player.posX);
				double l_ZDiff = Math.abs(Center.z - mc.player.posZ);

				if (l_XDiff <= 0.1 && l_ZDiff <= 0.1)
				{

				}
				else
				{
					double l_MotionX = Center.x-mc.player.posX;
					double l_MotionZ = Center.z-mc.player.posZ;

					mc.player.motionX = l_MotionX/2;
					mc.player.motionZ = l_MotionZ/2;

					return;
				}


			}



			EnumHand hand = Spark.switchManager.Switch(new SpecBlockSwitchItem(getUse()), ItemSwitcher.usedHand.Both);
			if(UseOtherBlocks.isOn() && hand == null)
				hand = Spark.switchManager.Switch(new HardSolidBlockSwitchItem(), ItemSwitcher.usedHand.Both);

			if(hand == null){
				this.setEnabled(false);
				return;

			}



			if(Rotate.isOn()){
				sendPlayerRot(90,90,true);
			}

			if(OneTick.isOn())
				status = 1;
		}

		if(status == 1){


			Spark.rotationManager.setCancelNextWalkingUpdate();


			sendPlayerPos(mc.player.posX, mc.player.posY + 0.41999998688698, mc.player.posZ, false);
			sendPlayerPos(mc.player.posX, mc.player.posY + 0.7531999805212, mc.player.posZ, false);



			sendPlayerPos(mc.player.posX, mc.player.posY + 1.001335979, mc.player.posZ, false);

			sendPlayerPos(mc.player.posX, mc.player.posY + 1.16610926, mc.player.posZ, false);





			EnumHand hand = Spark.switchManager.Switch(new SpecBlockSwitchItem(getUse()), ItemSwitcher.usedHand.Both);
			if(UseOtherBlocks.isOn() && hand == null)
				hand = Spark.switchManager.Switch(new HardSolidBlockSwitchItem(), ItemSwitcher.usedHand.Both);

			if(hand == null){
				this.setEnabled(false);
				return;

			}




			if(!BlockInteractUtil.processRightClickBlock(pos, EnumFacing.UP,false,hand,new Vec3d(mc.player.posX,pos.getY()+0.5,mc.player.posZ)))
				return;

			Spark.sendInfo("placing burrow block");





			if(OneTick.isOn())
				status = 2;



		}
		if(status == 2){
			Vec3i clip = getClip();

			sendPlayerPos(mc.player.posX+clip.getX(),  mc.player.posY+clip.getY(), mc.player.posZ+clip.getZ(),true);
		}

		status++;


	}


	boolean ignore = false;

	@SubscribeEvent
	public void onPacket(PacketSendEvent p) {
		if(p.getPacket() instanceof CPacketPlayer)
		{
			CPacketPlayer pack = p.getPacket();

			BlockPos floored = PlayerUtil.getPlayerPosFloored(mc.player,0.2);


			if(mc.world.getBlockState(floored).getBlock().material.isSolid()
					&& !mc.world.getBlockState(floored.add(0,1,0)).getBlock().material.isSolid()) {

				if (bypass.isOn() && !ignore) {
					mc.player.motionY = 0;
					if (!mc.world.getBlockState(PlayerUtil.getPlayerPosFloored(mc.player).add(0, 1, 0)).getBlock().material.isOpaque()) {
						mc.player.setPosition(mc.player.posX, mc.player.posY - 1e-10, mc.player.posZ);

						ignore = true;
						mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, false));
						mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + 1000, mc.player.posZ, false));
						ignore = false;

						pack.y = Math.round(pack.y) - 1e-10;

					}
				}
			}
		}
	}






	Block getUse(){
		Block use = Blocks.OBSIDIAN;

		switch (ItemMode.getValueName()) {
			case "Beacon":
				use = Blocks.BEACON;
				break;
			case "Echest":
				use = Blocks.ENDER_CHEST;
				break;
			case "Obsidian":
				use = Blocks.OBSIDIAN;
				break;
		}
		return use;
	}

	Vec3i getClip(){
		BlockPos c = PlayerUtil.getPlayerPosFloored(mc.player);

		if(isBurrowClipPos(c.add(0,2,0)))
			return new Vec3i(0,2,0);

		if(isBurrowClipPos(c.add(1,1,0)))
			return new Vec3i(1,1,0);
		if(isBurrowClipPos(c.add(-1,1,0)))
			return new Vec3i(-1,1,0);
		if(isBurrowClipPos(c.add(0,1,1)))
			return new Vec3i(0,1,1);
		if(isBurrowClipPos(c.add(0,1,-1)))
			return new Vec3i(0,1,-1);

		return new Vec3i(0,2,0);
	}
	boolean isBurrowClipPos (BlockPos p){
		return (!mc.world.getBlockState(p).getBlock().material.isSolid() && !mc.world.getBlockState(p.add(0,1,0)).getBlock().material.isSolid());
	}

	private void sendPlayerPos(double x, double y, double z, boolean onGround)
	{

		mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y, z, onGround));
	}
	private void sendPlayerPosRot(double x, double y, double z, float yaw,float pitch,boolean onGround)
	{

		mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(x, y, z,yaw,pitch, onGround));
	}
	private void sendPlayerRot(float yaw,float pitch,boolean onGround)
	{

		mc.player.connection.sendPacket(new CPacketPlayer.Rotation(yaw,pitch, onGround));
	}


}
