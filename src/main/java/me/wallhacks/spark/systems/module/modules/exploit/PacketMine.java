package me.wallhacks.spark.systems.module.modules.exploit;

import me.wallhacks.spark.Spark;
import me.wallhacks.spark.event.player.PacketReceiveEvent;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerDamageBlockEvent;
import me.wallhacks.spark.event.player.PlayerLivingTickEvent;
import me.wallhacks.spark.manager.BreakManager;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.module.modules.combat.CevBreaker;
import me.wallhacks.spark.systems.setting.SettingGroup;
import me.wallhacks.spark.systems.setting.settings.*;
import me.wallhacks.spark.util.MC;
import me.wallhacks.spark.util.WorldUtils;
import me.wallhacks.spark.util.player.InventoryUtil;
import me.wallhacks.spark.util.player.PlayerUtil;
import me.wallhacks.spark.util.player.itemswitcher.ItemSwitcher;
import me.wallhacks.spark.util.player.itemswitcher.SwitchItem;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.ItemForMineSwitchItem;
import me.wallhacks.spark.util.render.ColorUtil;
import me.wallhacks.spark.util.render.EspUtil;
import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.init.Blocks;
import net.minecraft.init.Enchantments;
import net.minecraft.init.Items;
import net.minecraft.init.MobEffects;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.network.play.server.SPacketBlockChange;
import net.minecraft.network.play.server.SPacketMultiBlockChange;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;
import java.util.Arrays;

@Module.Registration(name = "PacketMine", description = "Packet mine but good!",alwaysListening = true)
public class PacketMine extends Module implements MC {

	public static PacketMine instance;
	public PacketMine() {
		instance = this;

	}



	IntSetting delay = new IntSetting("PacketDelay", this, 4, 0, 8);
	BooleanSetting instant = new BooleanSetting("Instant", this, false);

	ModeSetting Switch = new ModeSetting("Switch", this, "Normal", Arrays.asList("Normal","SwitchBack","Const","Off","Silent"));
	BooleanSetting instaSwitch = new BooleanSetting("SwitchForInstant", this, true, v -> (!Switch.is("Off")));

	BooleanSetting useTps = new BooleanSetting("UseTps", this, false);


	DoubleSetting doneAfter = new DoubleSetting("DoneAfter",this,1,0.8,1.2);

	IntSetting breakTries = new IntSetting("BreakTries", this, 4,0,8);

	BooleanSetting disableOnFlag = new BooleanSetting("DisableOnFlag", this, false);




	SettingGroup renderG = new SettingGroup("Render", this);
	ModeSetting render = new ModeSetting("Render", renderG, "Vertical",Arrays.asList("Off","Vertical","Expand"));
	ColorSetting color = new ColorSetting("Color", renderG, new Color(0x3843DCC8, true));
	ColorSetting doneColor = new ColorSetting("DoneColor", renderG, new Color(0x3843DC5C, true));
	BooleanSetting fill = new BooleanSetting("FillBB", renderG, true);





	public boolean hasStarted = false;
	public BlockPos pos;
	EnumFacing facing;

	public double getProgress() {
		if(pos == null)
			return 0;

		return Math.min(getProgressReal()*getRelativeHardnessBestTool(pos), 1);
	}
	public int ticksFromDone() {
		if(pos == null)
			return Integer.MAX_VALUE;
		int f = (int)Math.max(0,(1/getRelativeHardnessBestTool(pos))-getProgressReal());
		return f;
	}

	double getProgressReal() {
		return (useTps.isOn() ? 0.05*Spark.tickManager.getTickRate()*progress : progress);
	}

	int progress = 0;

	int pauseTimer = 0;


	boolean isDown = false;


	BlockPos lastPos = null;

	@SubscribeEvent
	public void onBreak(PlayerDamageBlockEvent.Pre event){

		if(nullCheck() || event.getPos() == null)
			return;
		if(!isEnabled() && !isBreakManager)
			return;
		if (!WorldUtils.canBreak(event.getPos()))
			return;

		event.setReturnValue(false);
		event.setCanceled(true);

		//thing for only firing on click down
		if(isDown && (event.getPos().equals(lastPos)))
			return;
		isDown = true;

		//toggle thing
		if(event.getPos().equals(pos)){
			if(mc.gameSettings.keyBindAttack.isKeyDown())
				pos = null;
			return;
		}


		progress = 0;
		hasStarted = false;
		hasSwitched = false;

		isBreakManager = Spark.breakManager.doInstaMine();

		pos = event.getPos();
		lastPos = pos;
		facing = event.getFacing();
	}

	public boolean hasSwitched = false;



	Block breaking;

	boolean isBreakManager;
	int breakManagerBeenInactive = 0;

	@SubscribeEvent
	public void onUpdate(PlayerLivingTickEvent event) {

		if(isBreakManager)
		{
			if(!Spark.breakManager.doInstaMine())
			{
				breakManagerBeenInactive++;
				if(breakManagerBeenInactive > 40)
					isBreakManager = false;
			}
			else
				breakManagerBeenInactive = 0;
		}
		else if(!isEnabled())
		{
			if(pos != null)
				pos = null;
			return;
		}






		if(isDown && !mc.gameSettings.keyBindAttack.isKeyDown())
			isDown = false;


		pauseTimer--;

		update();

	}

	public boolean shouldBeGone = false;
	int flags = 0;

	AxisAlignedBB lastBB;

	public void update() {


		if(pos != null)
		{
			if(WorldUtils.canBreak(pos))
			{
				lastBB = mc.world.getBlockState(pos).getSelectedBoundingBox(mc.world, pos);

				//this line is needed to not fuck with cev breaker
				if(!CevBreaker.INSTANCE.isEnabled() || Spark.breakManager.block != null)
					tryMine();
				progress ++;
			}
			else{




				hasSwitched = !instaSwitch.isOn();
				shouldBeGone = false;
				flags = 0;
			}




		}
	}

	public boolean tryMine() {
		IBlockState b = mc.world.getBlockState(pos);
		if(breaking != null && breaking.blockHardness >= b.getBlock().blockHardness && hasStarted)
		{
			int lastSlot = mc.player.inventory.currentItem;
			if(!(Switch.is("Off") || hasSwitched))
				Spark.switchManager.SwitchUsingHotbar(new ItemForMineSwitchItem(b), ItemSwitcher.usedHand.Mainhand,false);
			float f = b.getPlayerRelativeBlockHardness(this.mc.player, this.mc.player.world, pos);
			mc.player.inventory.currentItem = lastSlot;

			boolean sentStopDestroyPackets = false;


			if(pauseTimer <= 0 && PlayerUtil.getDistance(pos) < 10 && getProgressReal() >= doneAfter.getFloatValue()/f)
			{

				Spark.switchManager.Switch(new ItemForMineSwitchItem(b), ItemSwitcher.usedHand.Mainhand,Switch.getValue(),Math.max(delay.getValue()+1,6));

				sentStopDestroyPackets = true;
				if(!Switch.is("Silent"))
					hasSwitched = true;

				mc.player.connection.sendPacket(new CPacketPlayerDigging(
						CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing
				));

				shouldBeGone = true;

				pauseTimer = delay.getValue();
			}





			if(sentStopDestroyPackets)
				return true;



		}
		else{
			mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
			mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
			hasStarted = true;
			hasSwitched = false;
			shouldBeGone = false;
			flags = 0;
			breaking = b.getBlock();
			progress = 0;


		}
		return false;
	}


	//saves last pos placed on
	BlockPos placed = null;

	@SubscribeEvent
	public void onPacketSend(PacketSendEvent event) {

		if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock)
		{
			CPacketPlayerTryUseItemOnBlock place = event.getPacket();
			placed = place.getPos().add(place.getDirection().getDirectionVec());
		}
		if (event.getPacket() instanceof CPacketPlayerDigging)
		{
			CPacketPlayerDigging digging = event.getPacket();
			if(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK == digging.getAction())
			{
				if(pos != null)
					event.setCanceled(true);
			}
		}

	}

	@SubscribeEvent
	public void onPacketGet(PacketReceiveEvent event) {
		if (event.getPacket() instanceof SPacketMultiBlockChange) {
			for (SPacketMultiBlockChange.BlockUpdateData pos : ((SPacketMultiBlockChange) event.getPacket()).getChangedBlocks()) {

				blockChanged(pos.getPos(),pos.getBlockState());
			}
		} else if (event.getPacket() instanceof SPacketBlockChange) {
			blockChanged(((SPacketBlockChange) event.getPacket()).getBlockPosition(),((SPacketBlockChange) event.getPacket()).blockState);
		}
	}
	protected void blockChanged(BlockPos p,IBlockState state) {
		if(!isEnabled() && !isBreakManager)
			return;

		//we need this
		if(p.equals(placed))
		{
			placed = null;
			return;
		}

		if(pos != null && shouldBeGone)
		{
			if(pos.equals(p))
			{
				if(state.getBlock() == Blocks.AIR)
				{
					if(!instant.isOn() && !Spark.breakManager.doInstaMine())
						pos = null;
					//we did it - block was mined
					shouldBeGone = false;
				}
				else
				{
					flags++;
					if(flags > breakTries.getValue())
					{
						Spark.sendInfo("Insta mine failed! Failed break attempts: "+flags);
						//flag
						if(disableOnFlag.isOn())
							pos = null;
						hasStarted = false;
						shouldBeGone = false;
					}

				}
			}
		}
	}








	@SubscribeEvent
	public void onRender(RenderWorldLastEvent event) {
		if(!isEnabled() && !isBreakManager)
			return;

		if(pos != null && !render.is("Off")) {
			AxisAlignedBB b = lastBB != null ? lastBB : mc.world.getBlockState(pos).getSelectedBoundingBox(mc.world, pos);
			IBlockState a = mc.world.getBlockState(pos);


			double f = getProgress();


			if(render.is("Vertical"))
			{
				b = new AxisAlignedBB(b.minX, b.minY, b.minZ, b.maxX, b.minY + (b.maxY - b.minY) * f, b.maxZ);
			}
			else {
				double xs = Math.abs(b.maxX-b.minX)/2f*(1-f);
				double ys = Math.abs(b.maxY-b.minY)/2f*(1-f);
				double zs = Math.abs(b.maxZ-b.minZ)/2f*(1-f);

				b = b.grow(-xs,-ys,-zs);
			}


			Color c = ColorUtil.lerpColor(color.getColor(),doneColor.getColor(),(float) f);

			EspUtil.boundingESPBox(b,c.brighter(), 2.0f);
			if(fill.isOn() && pos != null && WorldUtils.canBreak(pos))
				EspUtil.boundingESPBoxFilled(b,c);
		}
	}


	public static float getRelativeHardnessBestTool(BlockPos pos) {
		IBlockState state = mc.world.getBlockState(pos);
		float f = state.getBlockHardness(mc.world, pos);

		if (f < 0.0F)
			return 0.0F;
		return getDigSpeedBestTool(state) / f / 30.0F;
	}
	public static float getDigSpeedBestTool(IBlockState state)
	{

		ItemStack stack = ItemStack.EMPTY;
		float f = InventoryUtil.getDestroySpeed(stack,state);

		//find best
		for (int i = 0; i < mc.player.inventory.getSizeInventory(); i++) {
			final ItemStack s = mc.player.inventory.getStackInSlot(i);
			if(s.getDestroySpeed(state) > f)
			{
				stack = s;
				f = InventoryUtil.getDestroySpeed(stack,state);
			}
		}
		if(InventoryUtil.getDestroySpeed(mc.player.inventory.getItemStack(),state) > f)
		{
			stack = mc.player.inventory.getItemStack();
			f = InventoryUtil.getDestroySpeed(stack,state);
		}


		if (mc.player.isPotionActive(MobEffects.HASTE))
		{
			f *= 1.0F + (float)(mc.player.getActivePotionEffect(MobEffects.HASTE).getAmplifier() + 1) * 0.2F;
		}

		if (mc.player.isPotionActive(MobEffects.MINING_FATIGUE))
		{
			float f1;

			switch (mc.player.getActivePotionEffect(MobEffects.MINING_FATIGUE).getAmplifier())
			{
				case 0:
					f1 = 0.3F;
					break;

				case 1:
					f1 = 0.09F;
					break;

				case 2:
					f1 = 0.0027F;
					break;

				case 3:
				default:
					f1 = 8.1E-4F;
			}

			f *= f1;
		}

		if (mc.player.isInsideOfMaterial(Material.WATER) && !EnchantmentHelper.getAquaAffinityModifier(mc.player))
		{
			f /= 5.0F;
		}


		return f;
	}



}
